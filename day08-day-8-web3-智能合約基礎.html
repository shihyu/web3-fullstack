<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Day 8 - Web3 智能合約基礎 - Web3 Fullstack 開發 30 天</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Web3 Fullstack 開發 30 天</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-8day-8---web3-智能合約基礎"><a class="header" href="#day-8day-8---web3-智能合約基礎">DAY 8｜Day 8 - Web3 智能合約基礎</a></h1>
<ul>
<li>原文：https://ithelp.ithome.com.tw/articles/10320152</li>
<li>發佈時間：2023-09-17 00:20:56</li>
</ul>
<h2 id="章節內容"><a class="header" href="#章節內容">章節內容</a></h2>
<h3 id="1-未分章內容"><a class="header" href="#1-未分章內容">1. 未分章內容</a></h3>
<p>由於 Web3 與前端的主題暫時告一段落（後續會再有進階的 Web3 前端主題），作為到後端主題的銜接，如果對智能合約相關概念有更多理解的話會很有幫助，像前面我們有初步了解 ERC-20 的標準，不過還沒深入了解裡面的機制。因此今天會先從智能合約的開發語言與框架開始介紹，透過 ERC-20 作為範例講解一個代幣的實作邏輯，再介紹 NFT 的概念與機制。由於本系列文章不會專注於教大家如何寫智能合約，今天會是系列中唯一講到智能合約開發的。</p>
<h3 id="2-智能合約"><a class="header" href="#2-智能合約">2. 智能合約</a></h3>
<p>智能合約的定義其實很單純，如同 Ethereum 官方文件描述的：</p>
<blockquote>
<p>A "smart contract" is simply a program that runs on the Ethereum blockchain. It's a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain.</p>
</blockquote>
<p>所以其實嚴格來說他不是合約也沒那麼智能，Vitalik （以太坊的創始人）就提過應該要把它取名為 Persistent Scripts，不過既然已經廣為流傳，大家還是習慣叫他智能合約。以下是一個由 Solidity 寫的最簡單的智能合約，可以做到用 set 把一個資料存在這個合約上，並用 get 拿到這個資料。</p>
<p>[code]
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;</p>
<pre><code>contract SimpleStorage {
    uint256 private storedData;

    function set(uint256 _data) public {
        storedData = _data;
    }

    function get() public view returns (uint256) {
        return storedData;
    }
}
</code></pre>
<p>[/code]</p>
<h3 id="3-智能合約開發"><a class="header" href="#3-智能合約開發">3. 智能合約開發</a></h3>
<p>最廣為人知的智能合約開發語言就是 Solidity，他的寫法類似 Javascript 所以還算好上手。除了 Solidity 外也還也不少其他語言：</p>
<ul>
<li><a href="https://vyper.readthedocs.io/en/stable/index.html">Vyper</a>: 可以用類似 Python 的語法來寫智能合約，他的語法比較高階因此也蠻多人喜歡，按照 DeFi TVL 的統計數據目前是第二名（僅次於 Solidity）的語言。
<ul>
<li><a href="https://docs.soliditylang.org/en/latest/yul.html">Yul</a>: 寫法比較像組合語言，在 Solidity 中有時需要做底層的 gas fee 優化時會使用 inline assembly 的方式，Yul 就可以跟 Solidity 很好的結合</li>
<li><a href="https://huff.sh/">Huff</a>: 近期開始有不少討論度的底層語言，宣稱如果精通 EVM 的話可以寫出比 Yul 更省 gas fee 的合約。</li>
</ul>
</li>
</ul>
<p>更多關於這些語言的比較可參考：<a href="https://blog.chain.link/solidity-vs-vyper/">Solidity vs. Vyper: Which Smart Contract Language Is Right for Me?</a></p>
<p>再來是開發框架的簡介，以下幾個都是開發 Solidity 可以使用的框架：</p>
<ul>
<li><a href="https://remix.ethereum.org/">Remix</a>：較老牌的基於瀏覽器的 IDE，適合在雲端上快速實作原型。
<ul>
<li><a href="https://trufflesuite.com/">Truffle</a>：流行的開發框架，有內建的智能合約編譯、部署、測試的工具。</li>
<li><a href="https://hardhat.org/">Hardhat</a>：較新也比 Truffle 靈活的框架，更易於用來寫測試及 debug，像是有內建在合約中執行 console log 的 debug 方式。</li>
<li><a href="https://book.getfoundry.sh/">Foundry</a>：更新也比 Hardhat 更快的開發框架，提供純用 Solidity 寫的測試方式（相較於 Truffle Hardhat 都是用 Javascript 寫測試），許多人已經從 hardhat 換成使用 foundry。</li>
</ul>
</li>
</ul>
<p>關於這四個開發框架實際應用的方式，可以參考 <a href="https://ethereum-blockchain-developer.com/124-remix-vs-truffle-vs-hardhat-vs-foundry/00-overview">Remix vs Truffle vs Hardhat vs Foundry</a>。我個人學習的開發框架主要是 Hardhat 跟 Foundry，因為我比較喜歡學習新的框架跟體驗它的好處，讀者可以挑有興趣的框架學習，網路上都有大量相關的資源，或是從官方文件一個一個爬文就是很好的起點。</p>
<p>至於 Vyper 可以使用 <a href="https://github.com/eth-brownie/brownie">brownie</a> 來輔助開發跟測試，有學習 Vyper 的讀者也可以一併學。</p>
<h3 id="4-erc-20-token-contract-實作"><a class="header" href="#4-erc-20-token-contract-實作">4. ERC-20 Token Contract 實作</a></h3>
<p>接下來選一個 ERC-20 Token 我們實際來看他智能合約的實作。到 <a href="https://etherscan.io">Etherscan</a> 上搜尋 USDT 這個幣，就可以找到他的智能合約地址：<a href="https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7">0xdAC17F958D2ee523a2206206994597C13D831ec7</a></p>
<p><img src="images/day08-img001-28a8b28990.png" alt="images/day08-img001-28a8b28990.png" /></p>
<p>點擊中間的 Contract Tab 就可以看到這個智能合約完整的程式碼。因為所有智能合約都是在區塊鏈上，所以合約的執行邏輯也是公開透明的。只是會有智能合約是否開源的區別，像 USDT 的合約程式碼就有開源，任何人都可以查看是否有漏洞，智能合約開發者如果希望獲得社群的信任，通常就會把合約程式碼開源出來。至於沒有開源的合約會長得像這樣：</p>
<p><img src="images/day08-img002-a5df97f0f6.png" alt="images/day08-img002-a5df97f0f6.png" /></p>
<p>是一串看不懂的 bytecode，當然這個智能合約的執行邏輯還是公開透明的，因為 bytecode 就包含所有合約執行的邏輯，但這樣的缺點是不可讀也很難做審計，所以主要是用在要保護關鍵的邏輯不被別人知道時，例如一些套利程式的合約，或是一些惡意的合約可能刻意藏漏洞在裡面不讓別人發現。</p>
<p>回到 USDT 的合約，往下滑可以看到完整的程式碼，或是點擊 Read Contract 及 Write Contract 分別可以看到這個智能合約提供哪些讀取跟寫入方法。而因為在 Etherscan 上查看程式碼比較不方便（有時程式碼會分成多個檔案不好查詢），推薦使用 <a href="https://github.com/dethcrypto/dethcode">deth code viewer</a> 來看合約的程式碼。只要把原本的智能合約網址中 <code>etherscan.io</code> 改成 <code>etherscan.deth.net</code> 就可以了，也就是把 <a href="https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7"><code>https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7</code></a> 改成 <a href="https://etherscan.deth.net/address/0xdac17f958d2ee523a2206206994597c13d831ec7"><code>https://etherscan.deth.net/address/0xdac17f958d2ee523a2206206994597c13d831ec7</code></a> ，就可以看到以下類似 VS Code 的畫面</p>
<p><img src="images/day08-img003-122b7b20ce.png" alt="images/day08-img003-122b7b20ce.png" /></p>
<p>deth code viewer 也支援許多主流的 EVM chain explorer（<a href="https://github.com/dethcrypto/dethcode/blob/main/docs/supported-explorers.md">支援列表</a>），非常方便。</p>
<p>裡面可以看到一些關鍵的 ERC-20 function 的實作，包含 <code>transfer()</code>, <code>approve()</code>, <code>transferFrom()</code>, <code>balanceOf()</code>, <code>allowance()</code> 等等，先挑最簡單的 <code>balanceOf()</code> 來看</p>
<p>[code]
/**
* @dev Gets the balance of the specified address.
* @param _owner The address to query the the balance of.
* @return An uint representing the amount owned by the passed address.
*/
function balanceOf(address _owner) public constant returns (uint balance) {
return balances[_owner];
}</p>
<p>[/code]</p>
<p>可以看到一個地址的 balance 就是直接從 <code>balances</code> 這個 map 中取得，他的定義是</p>
<p>[code]
mapping(address =&gt; uint) public balances;</p>
<p>[/code]</p>
<p>因此 <code>balances</code> 這個 map 就是一般 ERC-20 合約最核心的資料，儲存所有地址的餘額。所以就很好理解 <code>transfer()</code> 裡做的事：</p>
<p>[code]
/**
* @dev transfer token for a specified address
* @param _to The address to transfer to.
* @param _value The amount to be transferred.
*/
function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {
uint fee = (_value.mul(basisPointsRate)).div(10000);
if (fee &gt; maximumFee) {
fee = maximumFee;
}
uint sendAmount = _value.sub(fee);
balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(sendAmount);
if (fee &gt; 0) {
balances[owner] = balances[owner].add(fee);
Transfer(msg.sender, owner, fee);
}
Transfer(msg.sender, _to, sendAmount);
}</p>
<p>[/code]</p>
<p>先忽略收取手續費的部分，最核心的邏輯就只是把 <code>msg.sender</code> （也就是發送交易的地址）的餘額減少 <code>_value</code>，並讓 <code>to</code> 地址的餘額增加 <code>_value</code> 而已。</p>
<p>再來介紹 <code>approve()</code>, <code>allowance()</code>, <code>transferFrom()</code>方法。因為有時在操作智能合約時，可能會遇到需要讓另一個智能合約把我的 USDT 轉走的情況，例如當我想在 Uniswap 上用 USDT 換成 ETH，其實我是跟 Uniswap 的合約互動，過程中 Uniswap 的合約會主動把我的 USDT 轉走並轉對應數量的 ETH 給我，因此才需要 <code>transferFrom()</code> 方法。來看一下裡面的實作：</p>
<p>[code]
/**
* @dev Transfer tokens from one address to another
* @param _from address The address which you want to send tokens from
* @param _to address The address which you want to transfer to
* @param _value uint the amount of tokens to be transferred
*/
function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3 * 32) {
var _allowance = allowed[_from][msg.sender];</p>
<pre><code>    // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met
    // if (_value &gt; _allowance) throw;

    uint fee = (_value.mul(basisPointsRate)).div(10000);
    if (fee &gt; maximumFee) {
        fee = maximumFee;
    }
    if (_allowance &lt; MAX_UINT) {
        allowed[_from][msg.sender] = _allowance.sub(_value);
    }
    uint sendAmount = _value.sub(fee);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(sendAmount);
    if (fee &gt; 0) {
        balances[owner] = balances[owner].add(fee);
        Transfer(_from, owner, fee);
    }
    Transfer(_from, _to, sendAmount);
}
</code></pre>
<p>[/code]</p>
<p>這個方法就是由發送交易的人把 <code>_from</code> 地址身上的 USDT 轉給 <code>_to</code> 地址。一樣先忽略計算 fee 的邏輯，由於不可能任何人都能把其他人的 USDT 轉走，第一行就是先去 <code>allowed</code> map 中看 <code>_from</code> 地址允許 <code>msg.sender</code> 使用多少 USDT，並在後面的 <code>_allowance.sub(_value)</code> 這行驗證 <code>_value</code> 是否小於等於 <code>_allowance</code> ，有的話就把他扣掉並設成新的 allowed 值（否則他會自動 throw exception 讓交易失敗）。所以只要我曾經允許過別的地址轉走我多少 USDT，那個地址隨時可以呼叫 <code>transferFrom()</code> 來把我的 USDT 轉走。因此通常只會允許智能合約來轉走自己的 USDT 而不會允許終端的錢包地址（Externally Owned Account, 又稱 EOA），因為智能合約只會在特定的邏輯中呼叫 <code>transferFrom()</code> 方法，不會隨便呼叫。</p>
<p>至於如何設定我要授權給該地址使用多少我的 USDT，就必須呼叫 <code>approve()</code> 方法：</p>
<p>[code]
/**
* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
* @param _spender The address which will spend the funds.
* @param _value The amount of tokens to be spent.
*/
function approve(address _spender, uint _value) public onlyPayloadSize(2 * 32) {</p>
<pre><code>    // To change the approve amount you first have to reduce the addresses`
    //  allowance to zero by calling `approve(_spender, 0)` if it is not
    //  already 0 to mitigate the race condition described here:
    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    require(!((_value != 0) &amp;&amp; (allowed[msg.sender][_spender] != 0)));

    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
}
</code></pre>
<p>[/code]</p>
<p>可以看到當我呼叫 <code>approve()</code> 時就是去改動 <code>allowed</code> map，把這個資訊存進合約供未來 <code>_spender</code> 可以呼叫 <code>transferFrom()</code>。而查詢我對特定地址的 USDT 授權數量則是使用 <code>allowance()</code></p>
<p>[code]
/**
* @dev Function to check the amount of tokens than an owner allowed to a spender.
* @param _owner address The address which owns the funds.
* @param _spender address The address which will spend the funds.
* @return A uint specifying the amount of tokens still available for the spender.
*/
function allowance(address _owner, address _spender) public constant returns (uint remaining) {
return allowed[_owner][_spender];
}</p>
<p>[/code]</p>
<p>以上講解了 ERC-20 合約中最關鍵的幾個方法，而 USDT 還有其他關於黑名單的變數與方法（<code>addBlackList()</code>, <code>isBlackListed</code> 等等）是用來封鎖駭客或是洗錢者的地址，他們的程式碼就留給讀者自行理解。</p>
<h3 id="5-智能合約的-event"><a class="header" href="#5-智能合約的-event">5. 智能合約的 Event</a></h3>
<p>在智能合約中除了變數與方法，還有一個概念沒有介紹到，也就是 Event。例如 <code>transferFrom()</code> 方法的最後一行其實會發出一個像這樣的 event: <code>Transfer(_from, _to, sendAmount)</code> ，在智能合約裡可以找到他的定義：</p>
<p>[code]
event Transfer(address indexed from, address indexed to, uint value);</p>
<p>[/code]</p>
<p>而 <code>Transfer</code> 也是 ERC-20 標準中定義的 Event。Event 可以用來方便查詢關於一個智能合約的歷史交易中，大家感興趣的事件。像當我想列出我的地址過去所有 USDT 的轉帳歷史時，如果要一個一個查詢我過去有跟 USDT 合約互動的紀錄會很麻煩，而且這還沒考慮到別人用 <code>transferFrom()</code> 把我 USDT 轉走的情況，就變成要看完所有跟 USDT 合約互動的交易才不會遺漏，而現在這些交易已經高達 1.7 億筆！</p>
<p>有了 Event 的機制，當 USDT 合約中有發生任何 Token Transfer 都發出 <code>Transfer</code> event 的話，等於是讓以太坊節點幫我們做 indexing，讓任何人可以直接 filter 出這個合約中特定內容的 event 有哪些。例如我想知道從我地址轉入或轉出 USDT 的所有記錄，就只要 filter 出 USDT 合約上 <code>from</code> 或是 <code>to</code> 的值等於我的地址的 Transfer Event 就可以了。後續會在後端的內容中介紹如何拿到 Token Transfer 的資料。</p>
<p>在 Etherscan USDT 介面上的 <a href="https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#events">Events Tab</a> 可以看到近期這個智能合約發出的 Events，以及每筆交易的 Logs Tab 可以看到該筆交易觸發了哪些智能合約中的哪些 Event（例如上次轉出 UNI token 的<a href="https://sepolia.etherscan.io/tx/0x8778dfe09585097badb32951bc34a1cb41c166045bd37f6b92885b40f5c26bfc#eventlog">交易 Logs</a>）。</p>
<h3 id="6-ft-vs-nft"><a class="header" href="#6-ft-vs-nft">6. FT vs NFT</a></h3>
<p>介紹完了 ERC-20 Token 接下來就能介紹更多的代幣標準，包含 ERC-721 及 ERC-1155。這裡就要講到 Fungible Token（FT） 跟 Non-Fungible Token（NFT） 之間的差別。</p>
<p>Fungible Token 又稱同質性代幣，前面介紹的 ERC-20 Token 就是屬於 Fungible Token，因為每一單位的 USDT 都是一樣的，如果 A 跟 B 都有 1 USDT，A 把他的 1 USDT 轉給 B，B 就會有兩個 USDT，代表 A 身上的 USDT 跟 B 身上的 USDT 是同質、沒有差異的。Fungible Token 的特性就是可以任意合併或拆分，適合用來實作貨幣的智能合約。</p>
<p>與之相對的就是 Non-Fungible Tokens，又稱非同質性代幣，代表每個 Token 都是獨一無二、不同質的。例如知名的 <a href="https://boredapeyachtclub.com/">Bored Ape Yacht Club (BAYC)</a> NFT 就是由一萬張 Ape 的圖片組成，每個 Ape 都有他對應的 ID、圖片、特色，因此就算我有兩個 BAYC NFT 他們也無法合併，而是兩個分開的 Token 並且可以各自被交易、轉移。NFT 也是無法分割的，沒辦法像 FT 一樣轉出 0.5 個 NFT。最知名的 NFT 標準包含 ERC-721 與 ERC-1155，常被用來實作像數位收藏品、遊戲道具、抽獎券等等可以對應到現實世界中「物品」或「資產」的概念。科普的介紹推薦看<a href="https://www.youtube.com/watch?v=cDk1FPoCfqI">老高關於 NFT 的介紹影片</a>。</p>
<p>至於 ERC-721 跟 ERC-1155 有怎樣的差別，簡單來說 ERC-721 代表的是每個 Token 都是獨一無二的 NFT，如數位藝術品每一件都是獨一無二的。ERC-1155 則是代表有部分 Token 是一樣的 NFT，例如遊戲中可能會有不同種類的藥水，但每種藥水本身是同質的沒有任何差異。背後的技術細節可以參考 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc721">ERC-721</a> 及 <a href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc1155">ERC-1155</a> 的介面定義，可以更了解這兩個標準的合約支援的操作。</p>
<h3 id="7-小結"><a class="header" href="#7-小結">7. 小結</a></h3>
<p>今天我們介紹了關於智能合約的開發、ERC-20 的實作與智能合約的 Event，以及在以太坊上實作 NFT 的兩個標準，接下來就會正式進入 Web3 與後端的開發了，會先延續前一天的錢包登入功能把它實作完成。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="day07-day-7-web3-與前端-實作錢包登入-part-1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="day09-day-9-web3-與後端-實作錢包登入-part-2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="day07-day-7-web3-與前端-實作錢包登入-part-1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="day09-day-9-web3-與後端-實作錢包登入-part-2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
