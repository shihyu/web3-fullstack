<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DAY 24｜Day 24 - Web3 與進階 App：DApp 瀏覽器實作 - Web3 全端工程師的技術養成之路</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Web3 全端工程師的技術養成之路</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-24day-24---web3-與進階-appdapp-瀏覽器實作"><a class="header" href="#day-24day-24---web3-與進階-appdapp-瀏覽器實作">DAY 24｜Day 24 - Web3 與進階 App：DApp 瀏覽器實作</a></h1>
<ul>
<li>原文：https://ithelp.ithome.com.tw/articles/10333681</li>
<li>發佈時間：2023-10-03 21:39:23</li>
</ul>
<h2 id="章節內容"><a class="header" href="#章節內容">章節內容</a></h2>
<h3 id="1-未分章內容"><a class="header" href="#1-未分章內容">1. 未分章內容</a></h3>
<p>今天要來介紹的是錢包 App 中的 DApp 瀏覽器如何實作，來幫助使用者在任何裝置與場景上都能方便透過錢包連上 DApp。這個功能在各個主流錢包 App 中都有提供，讀者不妨先試用過，會對今天的內容更加有感。</p>
<h3 id="2-dapp-瀏覽器介紹"><a class="header" href="#2-dapp-瀏覽器介紹">2. DApp 瀏覽器介紹</a></h3>
<p>昨天提到 Wallet Connect 適合的場景是錢包 App 連接桌面瀏覽器上的 DApp，而當如果使用者想要都在手機上操作 DApp，其實也可以使用 Wallet Connect。使用者可以在手機上選擇用 Chrome 或 Safari 等瀏覽器開啟 DApp，並在連接錢包時選擇用 Wallet Connect 連接，選擇對應的 App 後他會透過 Deep Link 的方式直接跳轉到錢包 App 中要求連接，並在後續每次需要簽名時直接用 Deep Link 跳轉到錢包 App。但這樣的做法會讓使用者在兩個 App 之間一直切換，並不順暢。</p>
<p>因此要在手機上操作 DApp 最直接的方式就是在錢包裡有個內建的瀏覽器可以用，並自動讓使用者的錢包連上瀏覽器中的 DApp，這樣就能在錢包 App 中流暢的進行所有的 DApp 操作了。這也是為什麼這個功能如此重要，對每個錢包 App 來說都是標配。下圖由左至右分別是 Metamask, Trust Wallet, KryptoGO Wallet 的 DApp 瀏覽器畫面：</p>
<p><img src="images/day24-img001-1622adccde.png" alt="https://ithelp.ithome.com.tw/upload/images/20231003/20162294vg1Qf4IFHx.png" /></p>
<h3 id="3-metamask-的開源實作"><a class="header" href="#3-metamask-的開源實作">3. Metamask 的開源實作</a></h3>
<p>要實作 DApp 瀏覽器需要將 DApp 與錢包 App 之間的通訊串起來，由於 Metamask 的 Mobile App 和 Extension 都是開源的，可以參考他們的實作方式並移植到 Flutter 中。</p>
<p>在 Metamask 的 Github 可以找到一個 <a href="https://github.com/MetaMask/mobile-provider">mobile-provider</a> repo，他其實是 Metamask Mobile App 中在開啟任何網頁時會用被注入進網頁的 JS Code，而且他是一個 Ethereum Wallet Provider（在 Day 16 有介紹過相關概念）。因此它提供了可以把瀏覽器中的 DApp 跟錢包 App 串起來的關鍵橋樑：當這個 Wallet Provider 從 DApp 接收到 JSON-RPC Request 時，他就會把這個請求丟給 Metamask Mobile App 處理，等待 App 處理完後拿到其回傳的結果再返回給 DApp，形成一個完整的 JSON-RPC 呼叫。</p>
<p>這個功能的核心在 <a href="https://github.com/MetaMask/mobile-provider/blob/main/src/inpage/MobilePortStream.js">MobilePortStream.js</a> 檔案中，可以看到有個 <code>MobilePortStream.prototype._write</code> function 如下：</p>
<p>[code]
MobilePortStream.prototype._write = function (msg, _encoding, cb) {
// ...
if (Buffer.isBuffer(msg)) {
const data = msg.toJSON();
data._isBuffer = true;
window.ReactNativeWebView.postMessage(
JSON.stringify({ ...data, origin: window.location.href }),
} else {
if (msg.data) {
msg.data.toNative = true;
}
window.ReactNativeWebView.postMessage(
JSON.stringify({ ...msg, origin: window.location.href }),
);
}
// ...
}</p>
<p>[/code]</p>
<p>因此所有 JSON RPC request 都會通過 <code>window.ReactNativeWebView.postMessage</code> 的方式打到 Metamask 用 React Native 實作的 App 中，而 <code>ReactNativeWebView</code> 這個 property 是由 <a href="https://github.com/react-native-webview/react-native-webview">react-native-webview</a> 套件提供的可以用來跟 React Native App 溝通的橋樑。</p>
<p>到這裡就可以想像出在 Flutter 中實作 DApp 瀏覽器的思路了：只要找一個 Flutter 瀏覽器的套件，然後把上面的 mobile-provider 程式碼中打到 React Native 的部分，換成打到 Flutter 瀏覽器提供的 property，這樣在 Flutter 中就可以用對應的 JSON RPC message handler 來接到請求並處理。</p>
<h3 id="4-flutter-瀏覽器套件"><a class="header" href="#4-flutter-瀏覽器套件">4. Flutter 瀏覽器套件</a></h3>
<p>Flutter 中有一個套件叫 <a href="https://inappwebview.dev/">flutter_inappwebview</a>，可以方便的在 App 中加入瀏覽器的功能，還允許我們自定義要注入的 script，而這正是在實作 DApp browser 功能所需要的。他的官方文件中關於 <a href="https://inappwebview.dev/docs/webview/javascript/communication/">JavaScript Communication 的介紹</a>就有提到如何從網頁端呼叫 App 端的程式碼：</p>
<p>[code]
const args = [1, true, ['bar', 5], {foo: 'baz'}];
window.flutter_inappwebview.callHandler('myHandlerName', ...args);</p>
<p>[/code]</p>
<p>只要呼叫 <code>window.flutter_inappwebview.callHandler</code> 即可 並且在 <code>InAppWebView</code> widget 中的 <code>onWebViewCreated</code> 可以使用 <code>controller.addJavaScriptHandler</code> 來加入對應的 handler：</p>
<p>[code]
onWebViewCreated: (controller) {
// register a JavaScript handler with name "myHandlerName"
controller.addJavaScriptHandler(handlerName: 'myHandlerName', callback: (args) {
// print arguments coming from the JavaScript side!
print(args);</p>
<pre><code>    // return data to the JavaScript side!
    return {
      'bar': 'bar_value', 'baz': 'baz_value'
    };
  });
},
</code></pre>
<p>[/code]</p>
<p>所以我們要做的就是將 Mobile Provider 中的 <code>window.ReactNativeWebView.postMessage</code>換成<code>window.flutter_inappwebview.callHandler</code>，就可以從 Mobile Provider 呼叫到 Flutter code 了：</p>
<p>[code]
if (Buffer.isBuffer(msg)) {
const data = msg.toJSON();
data._isBuffer = true;
window.flutter_inappwebview.callHandler(
'handleMessage',
JSON.stringify({ ...data, origin: window.location.href })
);
} else {
if (msg.data) {
msg.data.toNative = true;
}
window.flutter_inappwebview.callHandler(
'handleMessage',
JSON.stringify({ ...msg, origin: window.location.href })
);
}</p>
<p>[/code]</p>
<p>修改完<code>MobilePortStream.js</code>後可以執行 <code>yarn build</code>來產生 minimize 後的 JS code，就可以放入 Flutter 專案中並在後續注入進瀏覽器頁面中。</p>
<h3 id="5-將-dapp-瀏覽器串到-flutter"><a class="header" href="#5-將-dapp-瀏覽器串到-flutter">5. 將 DApp 瀏覽器串到 Flutter</a></h3>
<p><code>InAppWebView</code> widget 有提供在網頁中執行任意 JS Code 的方法（<a href="https://inappwebview.dev/docs/webview/javascript/user-scripts">官方文件</a>），包含使用 <code>initialUserScripts</code> 來在頁面開啟後的一開始執行 JS Code，或是使用 <code>controller.evaluateJavascript</code> 來在任意時間執行 JS Code。由於我們想在頁面載入時就把 mobille provider 注入進去，因此可以使用 <code>initialUserScripts</code> 屬性，搭配使用 <code>rootBundle.loadString('assets/js/init.js')</code> 把剛才編好的 JS Code 載入進來執行：</p>
<p>[code]
Future<String> browserInitScript = rootBundle.loadString('assets/js/init.js');</p>
<pre><code>// in widget
return FutureBuilder&lt;String?&gt;(
  future: browserInitScript,
  builder: (context, snapshot) {
    if (snapshot.hasData) {
      return InAppWebView(
        initialUserScripts: UnmodifiableListView&lt;UserScript&gt;([
          UserScript(
            source: snapshot.data ?? '',
            injectionTime: UserScriptInjectionTime.AT_DOCUMENT_START,
          ),
        ]),
        // ...
      );
    } else {
      return const Center(
        child: CircularProgressIndicator(),
      );
    }
  },
);
</code></pre>
<p>[/code]</p>
<p>裡面使用了 <code>FutureBuilder</code> 來處理還沒有載入完成 <code>init.js</code> 檔案的狀況，這樣就能成功在頁面載入時注入 Mobile Provider 了。</p>
<p>再來則是要監聽 DApp 端呼叫的 JSON-RPC Request 並回傳結果，因此需要在 <code>onWebViewCreated</code> 中註冊一個 JS handler：</p>
<p>[code]
onWebViewCreated: (controller) async {
controller.addJavaScriptHandler(
handlerName: 'handleMessage',
callback: (args) async {
final json = jsonDecode(args[0]);
// now json["data"] is the JSON-RPC request object
},
);
},</p>
<p>[/code]</p>
<p>只要 <code>handlerName</code> 中設定的值跟 Web 端在呼叫 <code>callHandler</code> 時使用一樣的名稱即可。這樣就可以拿到從 DApp 而來的 JSON-RPC 請求開始處理。</p>
<h3 id="6-實作-json-rpc-處理方法"><a class="header" href="#6-實作-json-rpc-處理方法">6. 實作 JSON-RPC 處理方法</a></h3>
<p>DApp 要實作的 JSON-RPC 方法非常多，<a href="https://docs.metamask.io/wallet/reference/eth_subscribe/">Metamask 官方文件</a>中就列出了近 50 個他支援的 JSON-RPC 方法，但其實有許多 JSON-RPC 方法可以直接傳遞給 Alchemy 來處理，包含 <code>eth_gasPrice</code>, <code>eth_blockNumber</code>, <code>eth_estimateGas</code> 等等，因為這些方法都是不依賴於當下連接的錢包，也跟簽名沒有關係。</p>
<p>在前面的內容我們已經介紹過 App 中簽名相關的 JSON-RPC method（包含 <code>eth_signTransaction</code>, <code>personal_sign</code>, <code>eth_signTypedData_v4</code>, …）以及如何簽名交易，因此今天相關的程式碼會省略。唯一要多處理的是當收到這些簽名請求時，需要跳出彈窗來讓使用者查看交易內容並決定接受或拒絕，若接受就走正常簽名流程，拒絕的話也需要回傳 JSON-RPC Error message 給 DApp 端。</p>
<p>還有另一類需要實作的 JSON-RPC method，是跟錢包本身相關的，例如：</p>
<ul>
<li><code>eth_requestAccounts</code>: 請使用者選擇一個要連接的錢包（<a href="https://docs.metamask.io/wallet/reference/eth_requestaccounts/">文件</a>）
<ul>
<li><code>wallet_addEthereumChain</code>: 請求新增一個 EVM 鏈（<a href="https://docs.metamask.io/wallet/reference/wallet_addethereumchain/">文件</a>）</li>
<li><code>wallet_switchEthereumChain</code>: 請求切換至另一個 EVM 鏈（<a href="https://docs.metamask.io/wallet/reference/wallet_switchethereumchain/">文件</a>）</li>
</ul>
</li>
</ul>
<p>跟 Ethereum Chain 相關的方法主要是用來管理錢包當下連接的鏈，因為一般 DApp 都會指定他只支援哪些鏈，而當使用者的錢包連上時不是使用對應的鏈，那 DApp 可以選擇用 <code>wallet_switchEthereumChain</code> 來請使用者切換鏈。</p>
<p>至於當使用者拒絕任何請求時（如簽名或新增/切換鏈），應該要回應什麼 JSON-RPC Response，也有在 JSON-RPC Error Code 中定義清楚，例如 <code>eth_requestAccounts</code> 方法當使用者拒絕時應該要回覆 <code>4001</code> error code 代表被拒絕，以及 <code>wallet_switchEthereumChain</code> 方法當錢包不支援該鏈的時候要回覆 <code>4902</code> 等等。Error Response 的格式也有在 <a href="https://eips.ethereum.org/EIPS/eip-1474">EIP-1474</a> 中定義：</p>
<p>[code]
{
"id": 1337
"jsonrpc": "2.0",
"error": {
"code": -32003,
"message": "Transaction rejected"
}
}</p>
<p>[/code]</p>
<p>有了這些概念後，就可以按照不同的 method 來實作 <code>handleMessage</code> 方法了，以下是範例的實作方式：</p>
<p>[code]
Future<dynamic> handleMessage(
String method,
List<dynamic> params,
) async {
switch (method) {
case "eth_requestAccounts":
// ...
if (userAccepted) {
return [wallet.address];
}
throw JsonRpcError(
code: 4001, message: "The request was rejected by the user");
case "eth_signTransaction":
// ...
if (userAccepted) {
return signTransaction(params);
}
throw JsonRpcError(
code: 4001, message: "The request was rejected by the user");
case "wallet_switchEthereumChain":
// ...
if (!chainSupported) {
throw JsonRpcError(
code: 4902, message: "Unrecognized chain ID.");
}
if (userAccepted) {
return switchEthereumChain(params);
}
throw JsonRpcError(
code: 4001, message: "The request was rejected by the user");</p>
<pre><code>		// add more cases here
    // e.g. eth_signTypedData_v4
		default:
			return postAlchemyRpc(method, params);
  }
}
</code></pre>
<p>[/code]</p>
<h3 id="7-回傳結果"><a class="header" href="#7-回傳結果">7. 回傳結果</a></h3>
<p>最後從 <code>handleMessage</code> 中得到回傳值時，就可以透過 <code>InAppWebView</code> 提供的 <code>controller.callAsyncJavaScript()</code> 方法來對頁面執行自訂的 JS Code，來把結果透過 <code>window.postMessage</code> 打回 Metamask mobile provider 中。由於 mobile-provider 中監聽的 target 是 <code>metamask-inpage</code>，因此傳遞的訊息中必須包含 <code>"target": "metamask-inpage"</code>。把以上程式碼串起來就是完整的實作方式了！</p>
<p>[code]
Future<String> browserInitScript = rootBundle.loadString('assets/js/init.js');</p>
<pre><code>// in widget
return FutureBuilder&lt;String?&gt;(
  future: browserInitScript,
  builder: (context, snapshot) {
    if (snapshot.hasData) {
      return InAppWebView(
        initialUserScripts: UnmodifiableListView&lt;UserScript&gt;([
          UserScript(
            source: snapshot.data ?? '',
            injectionTime: UserScriptInjectionTime.AT_DOCUMENT_START,
          ),
        ]),
        onWebViewCreated: (controller) async {
          controller.addJavaScriptHandler(
            handlerName: 'handleMessage',
            callback: (args) async {
              final json = jsonDecode(args[0]);
              final rpcId = (json["data"]["id"] is int)
                ? json["data"]["id"]
                : int.parse(json["data"]["id"]);
              final method = json["data"]["method"];
              final params = json["data"]["params"] ?? [];

              handleMessage(method, params).then((result) {
                controller.callAsyncJavaScript(
                  functionBody: _getPostMessageFunctionBody(rpcId, result),
                );
              }).catchError((e) {
                controller.callAsyncJavaScript(
                  functionBody: _getPostErrorMessageFunctionBody(rpcId, e),
                );
              });
            },
          );
        },
      );
    } else {
      return const Center(
        child: DefaultCircularProgressIndicator(),
      );
    }
  },
);

// util functions
String _getPostMessageFunctionBody(int id, dynamic result) {
  return '''
        try {
          window.postMessage({
            "target":"metamask-inpage",
            "data":{
              "name":"metamask-provider",
              "data":{
                "jsonrpc":"2.0",
                "id":$id,
                "result":${jsonEncode(result)}
              }
            }
          }, '*');
        } catch (e) {
          console.log('Error in evaluating javascript: ' + e);
        }
  ''';
}

String _getPostErrorMessageFunctionBody(int id, String error) {
  return '''
        try {
          window.postMessage({
            "target":"metamask-inpage",
            "data":{
              "name":"metamask-provider",
              "data":{
                "jsonrpc":"2.0",
                "id":$id,
                "error":$error
              }
            }
          }, '*');
        } catch (e) {
          console.log('Error in evaluating javascript: ' + e);
        }
  ''';
}
</code></pre>
<p>[/code]</p>
<p>KryptoGO Wallet 正是使用這樣的架構來實作 DApp browser 的功能，以下是實際運作時幾種請求用戶確認的畫面：</p>
<p><img src="images/day24-img002-0dd39edd5c.png" alt="https://ithelp.ithome.com.tw/upload/images/20231003/20162294vMTkLWunHj.png" /></p>
<h3 id="8-小結"><a class="header" href="#8-小結">8. 小結</a></h3>
<p>今天我們詳細介紹了 DApp 瀏覽器的原理以及如何在 App 中實作他，針對 mobile provider 我們有從 Metamask 的 repo 中 fork 出一個 Flutter 的版本，程式碼放在<a href="https://github.com/kryptogo/mobile-provider">這裡</a>。這兩天我們把 Wallet Connect 與 DApp browser 這兩個大幅增加錢包 App 便利性的功能完成了，接下來會介紹錢包 App 中要如何實作 Swap 功能，來讓使用者更方便的兌換任何代幣。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="day23-day-23-web3-與進階-app-wallet-connect-協議與實作.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="day25-day-25-web3-與進階-app-swap-功能實作.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="day23-day-23-web3-與進階-app-wallet-connect-協議與實作.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="day25-day-25-web3-與進階-app-swap-功能實作.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
