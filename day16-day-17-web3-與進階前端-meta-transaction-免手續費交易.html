<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DAY 16｜Day 17 - Web3 與進階前端：Meta Transaction 免手續費交易 - Web3 全端工程師的技術養成之路</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Web3 全端工程師的技術養成之路</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="day-16day-17---web3-與進階前端meta-transaction-免手續費交易"><a class="header" href="#day-16day-17---web3-與進階前端meta-transaction-免手續費交易">DAY 16｜Day 17 - Web3 與進階前端：Meta Transaction 免手續費交易</a></h1>
<ul>
<li>原文：https://ithelp.ithome.com.tw/articles/10327464</li>
<li>發佈時間：2023-09-26 00:23:16</li>
</ul>
<h2 id="章節內容"><a class="header" href="#章節內容">章節內容</a></h2>
<h3 id="1-未分章內容"><a class="header" href="#1-未分章內容">1. 未分章內容</a></h3>
<p>今天我們會介紹並實作一個可以讓使用者不需自己支付 Gas Fee 的機制，也就是 Meta Transaction，可以用來提升一般用戶的使用體驗，做為 Web3 與進階前端的收尾。</p>
<h3 id="2-meta-transaction-背景"><a class="header" href="#2-meta-transaction-背景">2. Meta Transaction 背景</a></h3>
<p>在發送任何以太坊上的交易時，都必需要有原生代幣（也就是 ETH）作為 Gas Fee 才能發送。但這也對使用者形成了一個門檻，想像一個場景是我跟別人買了一些 USDT 請他打到我的 ETH 錢包，這時我如果想把這些 USDT 轉走或是換成其他的幣就會無法送出交易，因為我還需要買一些 ETH 作為 Gas Fee。而今天要介紹的 Meta Transaction 就是想解決這個問題，來做到使用者不需要有 ETH 也能發送交易。</p>
<p>類似的場景也有很多，像有很多透過 NFT 做行銷的活動會希望讓使用者連接錢包後來領 NFT，但又不希望強制使用者要先買好 ETH (on Ethereum) 或 MATIC (on Polygon)，否則會造成許多用戶流失。</p>
<p>如果使用者想發交易卻又不想付手續費的話，有什麼可能的作法呢？一個想法是那使用者 A 只要簽名好一個「他想發 xxx 交易」的訊息就好（也就是他的「意圖」, intent），並把這個訊息交由另一個地址 B 發送交易，並透過智能合約的邏輯模擬出就像是 A 親自發出這筆交易一樣的效果，這樣就是一種 Meta Transaction 的作法了。</p>
<h3 id="3-erc-2771-合約標準"><a class="header" href="#3-erc-2771-合約標準">3. ERC-2771 合約標準</a></h3>
<p>一個實作 Meta Transaction 的方法是 <a href="https://eips.ethereum.org/EIPS/eip-2771">ERC-2771</a> 標準，裡面定義了如何將交易訊息打包並簽名、如何在鏈上驗證、合約中如何以簽名者的身份執行邏輯等等。以下是官方文件中的圖：</p>
<p><img src="images/day16-img001-9ef958853c.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/20162294emwg9hbdLr.png" /></p>
<p>可以看到這裡面有幾個角色</p>
<ul>
<li>Transaction Signer：想要發送交易但不想花 Gas Fee 的終端用戶，他只需要簽名一個 message
<ul>
<li>Gas Relay：拿到 Transaction Signer 簽出來的訊息跟原始資料後，負責把交易發到鏈上的地址，會由他支付 Gas Fee</li>
<li>Trusted Forwarder：這筆交易會呼叫的智能合約地址，負責驗證簽章是否有效，若通過會再呼叫目標合約</li>
<li>Recipient Contract：終端用戶想操作的智能合約</li>
</ul>
</li>
</ul>
<p>以下舉一個實際的例子應該會更好懂。NFT Worlds 是一個元宇宙項目，他們發行了自己的代幣 WRLD Token，對應在 Polygon 鏈上的智能合約在<a href="https://polygonscan.com/address/0xd5d86fc8d5c0ea1ac1ac5dfab6e529c9967a45e9">這裡</a>，切換到程式碼可以看到他實作的 <code>ERC2771Context</code> 這個 interface</p>
<p><img src="images/day16-img002-1dee7f2f06.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/20162294MmiRtMuKVI.png" /></p>
<p>這個合約就對應到上面的 Recipient Contract，代表 NFT Worlds 的項目方希望當用戶想轉移 WRLD Token 時，允許他們不需花自己的 gas fee。至於 Trusted Forwarder 合約則是在<a href="https://polygonscan.com/address/0x7fe3aedfc76d7c6dd84b617081a9346de81236dc">這裡</a></p>
<p><img src="images/day16-img003-6cc2e7e5e1.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/20162294B3GRwmZZNk.png" /></p>
<p>看一下這個合約相關的交易歷史，可以發現全部都是 <code>0x0853f256308a9d2efdb18f5ab9d6ce0cd4a622b4</code> 這個地址在呼叫 Trusted Forwarder 合約的 <code>Execute</code> 方法，到這裡就可以發現這個地址其實是 Gas Relay，因為他負責把交易打上鏈並支付 Gas Fee。那這些交易是如何運作的？可以點擊<a href="https://polygonscan.com/tx/0xad00037f6eac542544a68139702a7810b229e7ad8b1ead1d15b779ed075bc5c2">其中一筆交易</a>進去看：</p>
<p><img src="images/day16-img004-db1f28df34.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/20162294N4q8oXlA5x.png" /></p>
<p>雖然是 0x0853 發出的交易，但裡面的 Token Transfer 卻是從 0xacd0 這個地址轉出的，而再往下到 Input Data 區塊中點擊 Decode Input Data 可以看到這筆交易的 call data：</p>
<p><img src="images/day16-img005-298b5a6736.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/20162294E2y4fA7GbS.png" /></p>
<p>裡面的 from 地址就跟轉出 Token 的地址一致，代表 0xacd0 其實是這筆交易的 Transaction Signer，他做的操作是轉出他的 Token，只是請 0x0853 作為 Relayer 幫他支付 Gas Fee。</p>
<p>至於這位 Transaction Signer 實際想做什麼交易，只要看 <code>req.data</code> 的內容就會知道他想發給 Recipient Contract 的 call data 實際上是什麼：</p>
<p>[code]
0x08acece20000000000000000000000009ac8823dd1362c3b841d2faeaf6aba687755bf4c0000000000000000000000000000000000000000000000e3f41904f485900000</p>
<p>[/code]</p>
<p>這是一個被 encode ABI 函式 encode 過的字串，要知道他其實是什麼 function 可以使用前幾天提到的 <a href="https://openchain.xyz/tools/abi">Openchain ABI Tools</a>：</p>
<p><img src="images/day16-img006-364d23e92d.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/20162294wyHQVGEOlz.png" /></p>
<p>解析結果是 <code>transferWithFee()</code> function，看他的宣告可以猜到兩個參數分別是要轉去的地址跟數量（0x9ac8 也跟上面圖中收到 Token 的地址一致），於是到這裡我們就完全看懂這筆交易了！總結一下這筆交易中 ERC-2771 各個角色對應到的地址：</p>
<ul>
<li>Transaction Signer: <a href="https://polygonscan.com/address/0xacd095182dabb263649b93bb350363106fc3ecde">0xacd0</a>，他的錢包裡完全沒有 MATIC，卻想呼叫 WRLD Token 合約上的 <code>transferWithFee</code> function
<ul>
<li>Gas Relay: <a href="https://polygonscan.com/address/0x0853f256308a9d2efdb18f5ab9d6ce0cd4a622b4">0x0853</a>，也就是 NFT Worlds 項目方持有的專門代付 Gas Fee 的錢包</li>
<li>Trusted Forwarder: <a href="https://polygonscan.com/address/0x7fe3aedfc76d7c6dd84b617081a9346de81236dc">WRLD_Forwarder_Polygon</a></li>
<li>Recipient Contract: <a href="https://polygonscan.com/address/0xd5d86fc8d5c0ea1ac1ac5dfab6e529c9967a45e9">WRLD_Token_Polygon</a></li>
</ul>
</li>
</ul>
<h3 id="4-erc-2771-程式碼"><a class="header" href="#4-erc-2771-程式碼">4. ERC-2771 程式碼</a></h3>
<p>從實際發送出的交易已經看出整個 ERC-2771 的運作機制了，接下來就要進到合約中看 Trusted Forwarder 跟 Recipient Contract 是如何實作的，這樣我們才能把 ERC-2771 的標準整合進自己的合約中。可以先從 <a href="https://docs.openzeppelin.com/contracts/4.x/api/metatx">OpenZeppelin 的文件</a>來看 ERC-2771 相關的合約支援哪些方法，裡面定義了 Recipient Contract 需實作的 <code>ERC2771Context</code> 介面：</p>
<p>[code]
constructor(address trustedForwarder)
isTrustedForwarder(address forwarder) → bool
_msgSender() → address sender
_msgData() → bytes</p>
<p>[/code]</p>
<p>以及 Trusted Forwarder 需實作的 <code>MinimalForwarder</code> 介面：</p>
<p>[code]
constructor()
getNonce(address from) → uint256
verify(struct MinimalForwarder.ForwardRequest req, bytes signature) → bool
execute(struct MinimalForwarder.ForwardRequest req, bytes signature) → bool, bytes</p>
<p>[/code]</p>
<p>先從整筆交易的進入點 <code>execute()</code> 看起，參數裡有個 <code>MinimalForwarder.ForwardRequest</code> 結構，如果進到<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/metatx/MinimalForwarder.sol">原始碼</a>裡面看的話可以找到他的定義：</p>
<p>[code]
struct ForwardRequest {
address from;
address to;
uint256 value;
uint256 gas;
uint256 nonce;
bytes data;
}</p>
<p>[/code]</p>
<p>這跟剛才在 Polygonscan 上查看的交易資料結構一致，就是代表 Transaction Signer 希望對這個合約執行的操作，值得注意的是只需要傳入 gas 代表 gas limit 即可，不需傳入 gas price（因為 gas price 是 Gas Relay 發交易時決定的）。來看一下他的實作：</p>
<p><img src="images/day16-img007-6158290b92.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/201622946WQ4jYMrUP.png" /></p>
<p>簡單來說他做了一些檢查後，使用 <code>.call()</code> 去呼叫 Recipient Contract。前面的檢查用到了 <code>verify</code> function：</p>
<p><img src="images/day16-img008-0d28e2a867.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/20162294hedkoa4O4Z.png" /></p>
<p>可以看到 <code>verify</code> 先驗證這個 Signature 是否真的是 <code>req.from</code> 地址去簽名 Transaction Request 得到的值，而因為 Transaction Signer 簽的是 Typed Message（交易意圖有固定的欄位所以是結構化的資料），在鏈上也要用驗證 Sign Typed Message 的方法。</p>
<p>接下來比較有趣的是 nonce 的驗證， <code>_nonces</code> 是一個用來記錄 <code>req.from</code> 地址已經透過這個 Forwarder Contract 轉發多少交易的數量，類似每個 EVM 地址都有的 nonce 用來避免 Replay Attack，這裡需要 nonce 也是一樣的原因：不希望同樣一個 signature 可以被別人重複使用第二次，所以當 <code>verify</code> 驗證通過後會把 <code>_nonces[req.from]</code> 加一，來讓下一個有效的 signature 一定跟上過去用過的 signature 不同。因此 <code>ForwardRequest</code> 內的 <code>nonce</code> 值並不是該 <code>req.from</code> 地址本身的 nonce，而是 Forwarder Contract 自己紀錄的值。</p>
<p>最後在呼叫 Recipient Contract 時，會把 <code>req.data</code> 跟 <code>req.from</code> 連接起來，而這就對應到 Recipient Contract 中必須實作的 <code>ERC2771Context</code>：</p>
<p><img src="images/day16-img009-0030d32e33.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/20162294gPxa2kTIwf.png" /></p>
<p>當 Recipient Contract 想要知道現在是誰呼叫自己時，他必須判斷這筆交易是否為 Meta Transaction，如果是的話這筆交易的所有邏輯就必須針對 Transaction Signer 發生，否則就是對原始發送這筆交易的人（<code>msg.sender</code>）發生。至於當是 Meta Transaction 的情況要如何知道 Transaction Signer 是誰，剛才在 <code>.call</code> 時拼接在最後面的 <code>req.from</code> 資料就派上用場了，可以從 call data 中去抓最後 20 bytes 得到。</p>
<p>因此透過 <code>_msgSender()</code> function 把以上邏輯包起來，並在所有其他 function 中如果想知道當下是誰呼叫這個合約時都使用它，就能完成符合 ERC-2771 標準的合約實作。例如前面看到的 <code>transferWithFee</code> 長這樣：</p>
<p><img src="images/day16-img010-0e8a9a1925.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/20162294cHyEPuZuZ2.png" /></p>
<p>當要轉移代幣時，如果誤用了 <code>msg.sender</code> ，以前面的例子他就會把 0x0853 (Gas Relay) 地址的代幣轉走，但其實要轉走的應該是 0xacd0 (Transaction Signer) 的代幣才對。於是到這裡就把 ERC-2771 的實作介紹完了！</p>
<h3 id="5-前端實作"><a class="header" href="#5-前端實作">5. 前端實作</a></h3>
<p>當符合 ERC-2771 的智能合約被開發完後，若要把完整的流程串起來，還差兩個步驟：</p>
<ol>
<li>前端要組合需要的交易內容成 Typed Message 讓使用者簽名</li>
<li>把簽名送到後端，由後端的 Gas Relay 錢包發送交易上鏈</li>
</ol>
<p>由於後續的內容才會講到後端如何發送帶有 call data 的交易，今天先提供前端的實作方式。本質上要發送 ERC-2771 Transaction 需要兩個資訊：ForwardRequest 跟 Signature。也就是前端必須算好以下資料：</p>
<ul>
<li><code>from</code>, <code>to</code>, <code>value</code>, <code>gas</code>, <code>data</code>: 對合約進行操作的相關資料
<ul>
<li><code>nonce</code>: Forwarder Contract 上該地址的 nonce</li>
<li><code>signature</code>: 把上面這些資料組成 Typed Message 後讓用戶簽名後的資料</li>
</ul>
</li>
</ul>
<p>同樣以用戶想呼叫 NFT Worlds 合約中的 <code>transferWithFee(address,uint256)</code> function 為例，具體實作方式為：</p>
<ul>
<li><code>from</code>, <code>to</code>, <code>value</code>, <code>gas</code> 都可以設成固定的值
<ul>
<li><code>data</code> 要用 <code>viem</code> 中的 <code>encodeFunctionData</code> 來基於 ABI 去組</li>
<li><code>nonce</code> 要用 <code>useContractRead</code> 來到 Forwarder Contract 查最新的值</li>
<li><code>signature</code> 要用 <code>useSignTypedData</code> 來讓使用者簽名</li>
</ul>
</li>
</ul>
<p>前面先定義好 Forwarder Contract 跟 Recipient Contract 的地址跟 ABI 後，就可以把這些資料組出來了：</p>
<p>[code]
// read forwarder nonce
const { data: forwarderNonce } = useContractRead({
address: FORWARDER_CONTRACT_ADDRESS,
abi: forwarderABI,
functionName: "getNonce",
args: [address || NULL_ADDRESS],
chainId: 137,
});</p>
<pre><code>// encode transferWithFee function data
const gas = 100000n;
const data = encodeFunctionData({
  abi: recipientContractABI,
  functionName: "transferWithFee",
  args: ["0xE2Dc3214f7096a94077E71A3E218243E289F1067", 10000n],
});

// compose and sign typed data
const {
  data: signature,
  isError,
  error,
  signTypedData,
} = useSignTypedData({
  domain: {
    name: "WRLD_Forwarder_Polygon",
    version: "1.0.0",
    chainId: 137,
    verifyingContract: FORWARDER_CONTRACT_ADDRESS,
  } as const,
  primaryType: "ForwardRequest",
  types: {
    ForwardRequest: [
      { name: "from", type: "address" },
      { name: "to", type: "address" },
      { name: "value", type: "uint256" },
      { name: "gas", type: "uint256" },
      { name: "nonce", type: "uint256" },
      { name: "data", type: "bytes" },
    ],
  },
  message: {
    from: address || NULL_ADDRESS,
    to: TOKEN_CONTRACT_ADDRESS,
    value: 0n,
    gas,
    nonce: forwarderNonce || 0n,
    data,
  },
});

// in returned component
&lt;button
  onClick={() =&gt; {
    if (forwarderNonce !== undefined) {
      signTypedData();
    }
  }}
&gt;
  Sign Meta Transaction
&lt;/button&gt;
&lt;div&gt;Forwarder Nonce: {(forwarderNonce || 0n).toLocaleString()}&lt;/div&gt;
&lt;div&gt;Signature: {signature}&lt;/div&gt;
{isError &amp;&amp; &lt;div&gt;Error: {error?.message}&lt;/div&gt;}
</code></pre>
<p>[/code]</p>
<p>其中傳入 <code>useSignTypedData</code> 的是標準的 <a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712</a> 格式，他定義了如何在鏈上驗證 Typed Message 的標準，其中所需要的 <code>name</code> 跟 <code>version</code> 就會對應到 Forwarder Contract 上所記錄的自己的 name &amp; version。點擊 Sign Meta Transaction 後就可以看到 Metamask 跳出的簽名 Typed Message 的視窗：</p>
<p><img src="images/day16-img011-c6ce301289.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/201622942DG24SwzoJ.png" /></p>
<p>至於要如何驗證簽出來的簽章在鏈上可以被驗證通過呢？其實可以直接呼叫 Forwarder 中的 <code>verify</code> function，只要他回傳 <code>true</code> 就代表驗證成功，並顯示在畫面上：</p>
<p>[code]
// verify typed data
const { data: isVerified } = useContractRead({
address: FORWARDER_CONTRACT_ADDRESS,
abi: forwarderABI,
functionName: "verify",
args: [
{
from: address || NULL_ADDRESS,
to: TOKEN_CONTRACT_ADDRESS,
value: 0n,
gas,
nonce: forwarderNonce || 0n,
data,
},
signature || "0x",
],
chainId: 137,
enabled: !!address &amp;&amp; !!forwarderNonce &amp;&amp; !!signature,
});</p>
<pre><code>// in returned component
{isVerified &amp;&amp; &lt;div&gt;Signature verified!&lt;/div&gt;}
</code></pre>
<p>[/code]</p>
<p>最後看到 Signature verified 代表我們的簽章可以通過 Forwarder Contract 的驗證了！</p>
<p><img src="images/day16-img012-373453f239.png" alt="https://ithelp.ithome.com.tw/upload/images/20230926/201622944DeeVrebTZ.png" /></p>
<h3 id="6-小結"><a class="header" href="#6-小結">6. 小結</a></h3>
<p>今天我們詳細講解了 ERC-2771 的機制，包含發送交易的過程、智能合約的邏輯、前端簽名 Typed Data 的串接，完整程式碼在<a href="https://github.com/a00012025/ironman-2023-web3-fullstack/tree/main/frontend/day17">這裡</a>。其實 ERC-2771 只是其中一種實作 Meta Transaction 的方式，其他還有像 <a href="https://docs.opengsn.org/">Ethereum Gas Station Network</a> 也可以發送 Gasless Transaction。以及在最近正式通過的 <a href="https://eips.ethereum.org/EIPS/eip-4337">ERC-4337</a> 帳戶抽象化標準也是想解決 Gas Fee 支付的問題，這個會在後續的內容介紹到。</p>
<p>今天就是 Web3 與進階前端主題的最後一篇，接下來會進入 Web3 與進階後端，明天就會從今天也有提到的「從後端發送帶有 call data 的交易」開始介紹，讓讀者有能力實作完整 Meta Transaction 的流程。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="day15-day-15-web3-與進階前端-revoke-cash-與-logs-查詢.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="day17-day-16-web3-與進階前端-瀏覽器錢包-extension-原理.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="day15-day-15-web3-與進階前端-revoke-cash-與-logs-查詢.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="day17-day-16-web3-與進階前端-瀏覽器錢包-extension-原理.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
